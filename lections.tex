\documentclass[12pt]{article}

\usepackage {preamble}

\begin{document}

\author{}
\title{Структуры данных и алгоритмы}
\date{3 семестр, 2025}
\maketitle

Принципы ООП:
\begin{enumerate}
\item Абстракция;
\item Инкапсуляция;
\item Наследование (иерархия);
\item Полиморфизм;
\item Модульность.
\end{enumerate}

Объект "--- сущность, имеющвя чётко определённые границы и поведение.

Класс "---  набор объектов, обладающих одинаковым набором характеристик и функционала.

struct "--- все поля public.

class "--- по умолчанию всё private, если не написано public.

Виды полей:
\begin{enumerate}
\item private: может вызывать только сам объект;
\item public: могут вызывать все.
	\begin{itemize}
	\item get;
	\item set;
	\item iterate;
	\item конструктор (MyClass());
	\item деструктор (~MyClass(), обычно содержится free, отвечающий за освобождение ресурсов.
	\end{itemize}
\item  protected: могут вызывать только потомки.
\end{enumerate}

Наследование:
\begin{enumerate}
\item is as "--- это разновидность того;
\item part of "--- это часть того;
\end{enumerate}

class b: public a

virtual "--- абстрактная функция (у потомков её можно переопределить)

Множественное наследование всегда можно заменить другим видом иерархии (отношением агрегирования/это часть того). Ромбовидное наследование "--- плохо.

Python "--- можно получить доступ к private методам!

obj.i\_\_param "--- ошибка доступа.

obj.\_\_SomeClass.\_\_param "--- получили доступ!

static "--- переменная, одна на все объекты класса.

Многозадачности не существует, если у нас один процессор.

Приведение типов:
\begin{itemize}
\item static\_cast;
\item reinterpret\_cast;
\item dynamic\_cast "--- самый нормальный вариант (то, что нужно, или NULL).
\end{itemize}

Исключения:
\begin{itemize}
\item Ловим всё, в т.ч. ошибки ОС

try {

}

catch(...) {

}

\end{itemize}

\item Исключение в конструкторе \rightarrow объект не создался, по умолчанию вызвалось delete

\textbf{Rust}
mod (модуль) "--- самая маленькая единица инкапсуляции

pub "--- публичное поле (по умолчанию все поля private)

Композиция "--- в дочернем классе содержится поле с экземпляром родительского класса, методы нужно заново задавать с помощью прокси"=метода

trait "--- набор методов, которые должен осуществлять класс

impl Trait for Class

Типы могут реализовывать функции, тело которых не прописано в trait, по"=своему

Единственное, зачем нужны базовые классы и множественное наследование, "--- чтобы объекты реализовывали нужный функционал. Для этого в Rust используются traitы.

Масштабирование traitов "--- данный trait применим только к тем объектам, которые уже обладают родительским traitом.

Паттерны проектирования "--- некоторые общепринятые идеи, общее описание хорошего способа решения задачи. Изначально было 23 паттерна

Антипаттерн "--- неудачное решение: хардкод, магические числа, магическая кнопка, ненужная сложность, спагетти"=код

\begin{enumerate}
\item Алгоритмы процедурного программирования "--- паттерны вычислений
\item Архитектурные паттерны
\end{enumerate}

Синхронизация "--- механизм ОС, обеспечивающий согласованное во времени выполнение нескольких процессов или потоков.

Типы процессов:
\begin{enumerate}
\item сихнронные (связаны)
\item несихронные (не связаны, выполняются независимо)
\item асинхронные (связаны на некоторых этапах выполнения)
\end{enumerate}

Разделяемый (критический) ресурс "--- может использоваться несколькими процессами или потоками параллельно.

Критическая секция "--- область кода, при выполнении которой происходит обращение к критическому ресурсу.

Взаимоисключение "--- механизм операционной системы, позволяющий реализовать синхронный вход процессов в свои критические секции.

Mutex "--- объект ядра ОС, обеспечивающий взаимоисключение потоков. Открыт "--- поток может войти в критическую секцию, закрыт "--- не может.

Семафоры "--- лбъекты синхронизации: есть бинарные и считающие (несколько процессов могут одновременно войти в свою критическую секцию). В отличие от mutex, семафоры реализуют активное ожидание.

\end{document}
